"""
Tesseract-AppSync (TesSync) is a wrapper that automatically creates
types, functions and resolvers for all the insights generated by
Tesseract, so that, they could be queried over GraphQL API
"""

import boto3

from tesseract.wrappers.wrapper_config import (
    CODE_BUCKET,
    INSIGHT_INPUT,
    SYNC_API_ID,
    SYNC_LAMBDA_RESOLVEARN,
    SYNC_SOURCE_ROLEARN,
)

# logging.basicConfig(level=logging.INFO)


class Tessync:
    # construtor

    def __init__(self, logger, tessync_client):
        self.logger = logger
        self.tessync_client = tessync_client
        self.scalar_type = {
            "string": "String",
            "int": "Int",
            "smallint": "Int",
            "bigint": "Int",
            "float": "Float",
            "double": "Float",
            "decimal": "Float",
            "boolean": "Boolean",
        }
        self.type_schema = {}

    def delete_resources(self, insight_name):
        self.logger.info("TesSync: delete_resources: Function Entered")
        try:
            response = self.tessync_client.delete_type(
                apiId=SYNC_API_ID, typeName=insight_name
            )
            self.logger.info(
                "TesSync: delete_resources: Type Deletion Status " + str(response)
            )
            response = self.tessync_client.get_type(
                apiId=SYNC_API_ID, typeName="Query", format="SDL"
            )
            old_type_definition = response["type"]["definition"]
            print(old_type_definition)
            definition_array = old_type_definition.split("\n")
            updated_definition_array = []
            funct_substr = "get_" + insight_name + "("
            for metric_func in definition_array:
                if funct_substr not in metric_func and len(metric_func.strip()) > 0:
                    updated_definition_array.append(metric_func)
            updated_type_definition = "\n".join(updated_definition_array)
            response = self.tessync_client.update_type(
                apiId=SYNC_API_ID,
                typeName="Query",
                format="SDL",
                definition=updated_type_definition,
            )
            self.logger.info(
                "TesSync: create_resources: Updated Type Definition "
                + str(response["type"]["definition"])
            )
        except BaseException as e:
            self.logger.error(
                "TesSync: delete_resources: Type Deletion error "
                + str(insight_name)
                + " "
                + str(e)
            )
        try:
            response = self.tessync_client.delete_data_source(
                apiId=SYNC_API_ID, name="src_" + insight_name
            )
            self.logger.info(
                "TesSync: delete_resources: Data Source Deletion Status "
                + str(response)
            )
        except BaseException as e:
            self.logger.error(
                "TesSync: delete_resources: Data Source Deletion error "
                + str(insight_name)
                + " "
                + str(e)
            )
        try:
            response = self.tessync_client.delete_resolver(
                apiId=SYNC_API_ID, typeName="Query", fieldName="get_" + insight_name
            )
            self.logger.info(
                "TesSync: delete_resources: Resolver Deletion Status " + str(response)
            )
        except BaseException as e:
            self.logger.error(
                "TesSync: delete_resources: Resolver Deletion error "
                + str(insight_name)
                + " "
                + str(e)
            )

    def create_resources(self, insight_name, storage, insight_key):
        self.logger.info("TesSync: create_resources: Function Entered")
        try:
            if storage == "dynamo":
                response = self.tessync_client.create_data_source(
                    apiId=SYNC_API_ID,
                    name="src_" + insight_name,
                    description="data source created by tesseract",
                    serviceRoleArn=SYNC_SOURCE_ROLEARN,
                    type="AMAZON_DYNAMODB",
                    dynamodbConfig={
                        "tableName": "tesseract_" + insight_name,
                        "awsRegion": "us-west-2",
                    },
                )
                self.logger.info(
                    "TesSync: create_resources: Dynamo Data Source Status "
                    + str(response)
                )
            else:
                response = self.tessync_client.create_data_source(
                    apiId=SYNC_API_ID,
                    name="src_" + insight_name,
                    description="data source created by tesseract",
                    serviceRoleArn=SYNC_SOURCE_ROLEARN,
                    type="AWS_LAMBDA",
                    lambdaConfig={"lambdaFunctionArn": SYNC_LAMBDA_RESOLVEARN},
                )
                self.logger.info(
                    "TesSync: create_resources: Lambda Data Source Status "
                    + str(response)
                )
        except BaseException as e:
            self.logger.error(
                "TesSync: create_resources: Data Source Creation error "
                + str(insight_name)
                + " "
                + str(e)
            )

        type_definition = self.generate_type_definition(insight_name, insight_key)
        self.logger.info("TesSync: create_resources: Type Definition")
        self.logger.info(type_definition)
        try:
            response = self.tessync_client.create_type(
                apiId=SYNC_API_ID, definition=type_definition, format="SDL"
            )
            self.logger.info(
                "TesSync: create_resources: Type Creation Status " + str(response)
            )
            response = self.tessync_client.get_type(
                apiId=SYNC_API_ID, typeName="Query", format="SDL"
            )
            function_to_update = (
                "get_"
                + insight_name
                + "("
                + insight_key
                + ": "
                + self.type_schema[insight_key]
                + "): "
                + insight_name
            )
            old_type_definition = response["type"]["definition"]
            print(old_type_definition)
            definition_array = old_type_definition.split("\n")
            updated_definition_array = []
            funct_substr = "get_" + insight_name + "("
            for metric_func in definition_array:
                if funct_substr not in metric_func and len(metric_func.strip()) > 0:
                    updated_definition_array.append(metric_func)
            updated_definition_array.insert(2, function_to_update)
            updated_type_definition = "\n".join(updated_definition_array)
            print("*******")
            print(updated_type_definition)
            response = self.tessync_client.update_type(
                apiId=SYNC_API_ID,
                typeName="Query",
                format="SDL",
                definition=updated_type_definition,
            )
            self.logger.info(
                "TesSync: create_resources: Updated Type Definition "
                + str(response["type"]["definition"])
            )
            request_template = self.get_vtl_template(
                insight_name, storage, insight_key, "request"
            )
            response_template = self.get_vtl_template(
                insight_name, storage, insight_key, "response"
            )
            print("-----------------")
            print(request_template)
            print("-----------------")
            print(response_template)
            response = self.tessync_client.create_resolver(
                apiId=SYNC_API_ID,
                typeName="Query",
                fieldName="get_" + insight_name,
                dataSourceName="src_" + insight_name,
                requestMappingTemplate=request_template,
                responseMappingTemplate=response_template,
            )
            self.logger.info(
                "TesSync: create_resources: Updated Type Definition " + str(response)
            )
        except BaseException as e:
            self.logger.error(
                "TesSync: create_resources: Type Creation error "
                + str(insight_name)
                + " "
                + str(e)
            )
            return False

    def get_vtl_template(self, insight_name, storage, insight_key, template_type):
        if storage == "dynamo":
            if template_type == "request":
                request_template = """
                {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                    "__KEY__": $util.dynamodb.toDynamoDBJson($ctx.args.__KEY__)
                  },
                }
                """
                request_template = request_template.replace("__KEY__", insight_key)
                return request_template
            elif template_type == "response":
                return "$util.toJson($context.result)"
        if template_type == "request":
            request_template = """
            {
                "version": "2018-05-29",
                "operation": "Invoke",
                "payload": {
                    "method": "__METHOD_NAME__",
                    "key": "__KEY__",
                    "arguments": $util.toJson($context.arguments)
                }
            }
            """
            request_template = request_template.replace(
                "__METHOD_NAME__", "get_" + insight_name
            )
            request_template = request_template.replace("__KEY__", insight_key)
            return request_template
        elif template_type == "response":
            return "$util.toJson($context.result)"
        return None

    def generate_type_definition(self, insight_name, insight_key):
        s3_resx = boto3.resource("s3")
        type_definition = "type " + insight_name + " {"
        try:
            s3Obj = s3_resx.Object(
                CODE_BUCKET, INSIGHT_INPUT + insight_name + "/" + insight_name + ".ddl"
            )
            ddl_content = s3Obj.get()["Body"].read().decode("utf-8")
            schema_json = {}
            ddl_array = ddl_content.split("\n")
            for ddl_term in ddl_array:
                if ddl_term is not None and len(ddl_term.strip()) > 2:
                    term_array = ddl_term.split(" ")
                    schema_json[term_array[0]] = self.get_type(term_array[1])
            schema_json[insight_key] = schema_json[insight_key] + "!"
            self.logger.info(schema_json)
            self.type_schema = schema_json
        except BaseException as e:
            self.logger.error(
                "TesSync: generate_type_definition: Type Creation error "
                + str(insight_name)
                + " "
                + str(e)
            )
            return None
        for key, value in self.type_schema.items():
            type_definition += "\n" + key + ": " + value
        type_definition += "\n" + "}\n"
        return type_definition

    def get_type(self, type_string):
        type_string = type_string.replace(",", "").strip().lower()
        if "array" in type_string:
            req_label = type_string.replace("array<", "")
            req_label = req_label.replace(">", "").strip()
            return "[" + self.scalar_type[req_label] + "]"
        elif "decimal" in type_string:
            return "Float"
        return self.scalar_type[type_string]
